# Задачи ООП для Junior Python (с принципами SOLID)

Это репозиторий для решения задач ООП с соблюдением принципов SOLID.

## Установка

Клонируйте репозиторий:

```bash
git clone https://github.com/ZeroNiki/OOP-SOLID.git

cd OOP-SOLID
```

## Использование

Посмотрите вывод:

```bash
python start.py
```

Пример использования в `src/main.py`.

## ООП

Давайте рассмотрим принципы ООП на одном примере: **Управление задачами**.

### Пример: Управление задачами

Мы определим простую систему управления задачами, где можно создавать задачи и управлять ими.

#### 1. Инкапсуляция

**Определение:** Инкапсуляция — это механизм скрытия внутреннего состояния объекта и предоставления методов для взаимодействия с ним.

**Пример кода:**
Класс `Task` инкапсулирует свойства задачи, такие как `title`, `description` и `status`, и предоставляет методы для взаимодействия с этими свойствами.

```python
class Task:
    def __init__(self, title, description, status="open"):
        self._title = title
        self._description = description
        self._status = status  # Статус можно изменить через метод

    def mark_as_completed(self):
        self._status = "completed"
```

**Объяснение:** Здесь внутренние атрибуты задачи префиксированы знаком подчеркивания (например, `_title`, `_status`), что указывает на то, что к ним не следует обращаться напрямую из-за пределов класса. Вместо этого предоставляются методы, такие как `mark_as_completed`, для безопасного изменения статуса.

#### 2. Наследование

**Определение:** Наследование позволяет создавать новый класс на основе существующего класса, унаследуя его свойства и методы.

**Пример кода:**
Мы можем создать подклассы для различных типов задач, такие как `UrgentTask`, которые наследуются от `Task`.

```python
class UrgentTask(Task):
    def __init__(self, title, description):
        super().__init__(title, description, status="urgent")
```

**Объяснение:** Класс `UrgentTask` расширяет класс `Task`, добавляя конкретный тип задачи без дублирования кода. Он наследует метод `mark_as_completed` и любую другую функциональность, определенную в классе `Task`.

#### 3. Полиморфизм

**Определение:** Полиморфизм позволяет использовать различные классы через один интерфейс.

**Пример кода:**
Мы можем создать функцию, которая отображает задачу и принимает как объекты `Task`, так и `UrgentTask`.

```python
def display_task(task: Task):
    print(f"Title: {task._title}, Status: {task._status}")
```

**Объяснение:** Функция `display_task` может принимать любой объект типа `Task` или его подклассов, что позволяет гибко представлять и отображать задачи. Это полезно для обработки различных типов задач без необходимости знать их конкретный класс.

#### 4. Абстракция

**Определение:** Абстракция позволяет выделить важные характеристики объекта, скрывая ненужные детали.

**Пример кода:**
Класс `TaskManager` может управлять задачами, не зная деталей реализации каждой задачи.

```python
class TaskManager:
    def __init__(self):
        self._tasks = []

    def add_task(self, task: Task):
        self._tasks.append(task)

    def display_all_tasks(self):
        for task in self._tasks:
            display_task(task)
```

**Объяснение:** Класс `TaskManager` предоставляет высокий уровень интерфейса для управления задачами, такими как добавление и отображение задач, не раскрывая внутренние детали о том, как задачи хранятся или обрабатываются. Это помогает пользователям `TaskManager` сосредоточиться на его функциональности, а не на реализации задач.

## SOLID

Принципы SOLID — это набор из пяти основных принципов объектно-ориентированного проектирования, которые помогают создавать более понятные, гибкие и поддерживаемые системы. Давайте рассмотрим каждый из этих принципов с примерами из вышеупомянутых задач.

### 1. S - Принцип единственной ответственности (Single Responsibility Principle)

**Определение:** Каждый класс должен иметь только одну ответственность, и эта ответственность должна быть полностью инкапсулирована в классе.

**Пример:**
В задаче управления задачами класс `Task` отвечает только за представление задачи, в то время как класс `TaskManager` отвечает за управление коллекцией задач. Таким образом, если изменится способ управления задачами (например, добавление дополнительных операций), мы сможем изменить `TaskManager`, не затрагивая `Task`.

```python
class Task:
    def __init__(self, title, description, status="open", due_date=None):
        self.title = title
        self.description = description
        self.status = status
        self.due_date = due_date

class TaskManager:
    def __init__(self):
        self.tasks = []

    def add_task(self, task):
        self.tasks.append(task)
```

### 2. O - Принцип открытости/закрытости (Open/Closed Principle)

**Определение:** Классы должны быть открыты для расширения, но закрыты для модификации.

**Пример:**
В калькуляторе, если мы хотим добавить новые операции (например, возведение в степень), мы можем создать новый класс `Power`, который наследует от `Operation`, не изменяя код самого класса `Calculator`.

```python
class Power(Operation):
    def execute(self, a, b):
        return a ** b

class Calculator:
    def __init__(self):
        self.operations = {
            '+': Add(),
            '-': Subtract(),
            '*': Multiply(),
            '/': Divide(),
            '**': Power()  # Новая операция
        }
```

### 3. L - Принцип подстановки Лисков (Liskov Substitution Principle)

**Определение:** Объекты подкласса должны быть взаимозаменяемыми с объектами суперкласса без изменения желаемых свойств программы.

**Пример:**
В калькуляторе все операции (например, `Add`, `Subtract`, `Multiply`, `Divide`) реализуют интерфейс `Operation`. Это позволяет использовать любые операции в классе `Calculator`, не проверяя, какая операция передана.

```python
class Operation:
    def execute(self, a, b):
        raise NotImplementedError

class Add(Operation):
    def execute(self, a, b):
        return a + b
```

### 4. I - Принцип разделения интерфейса (Interface Segregation Principle)

**Определение:** Клиенты не должны зависеть от интерфейсов, которые они не используют.

**Пример:**
Предположим, что в задаче управления пользователями мы создаем различные интерфейсы для управления пользователями, такие как `UserCreation`, `UserRetrieval` и т. д. Это позволит избежать ситуаций, когда класс, реализующий один интерфейс, вынужден реализовывать ненужные методы.

```python
class UserCreation:
    def create_user(self, name, email):
        pass

class UserRetrieval:
    def get_user(self, user_id):
        pass
```

### 5. D - Принцип инверсии зависимостей (Dependency Inversion Principle)

**Определение:** Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа модулей должны зависеть от абстракций.

**Пример:**
В системе управления заказами `OrderManager` может зависеть от абстракции, представляющей источник хранения заказов (например, база данных или файловая система), а не от конкретного класса, реализующего это хранилище.

```python
class OrderRepository:
    def save_order(self, order):
        pass

class OrderManager:
    def __init__(self, repository: OrderRepository):
        self.repository = repository

    def add_order(self, order):
        self.repository.save_order(order)
```
